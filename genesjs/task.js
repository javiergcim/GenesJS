export class Task{constructor(){this.population=null;this.current_gen=null;this.desired_size=null;this.target_obj=null;this.constraints=null;this.mutator=null;this.mutator_args=[];this.crossover=null;this.crossover_args=[];this.selector=null;this.selector_args=[];this.objectives=null;this.obj_factors=null;this.func_args=[];this.data=null}get_population(){return this.population}get_subpopulation_copy(slice_l,slice_r){let copy=[];for(let i=slice_l;i<slice_r;i++){copy.push(this.population[i].clone())}return copy}replace_population(pop){this.population=pop}set_population(pop){this.population=pop;this.desired_size=pop.length}append_population(pop,first=false){if(first){this.population=pop.concat(this.population)}else{this.population=this.population.concat(pop)}}adjust_population_size(n=null){let current_size=this.population.length;let max_index=current_size-1;let re_evaluate;let index;let born;if(n===null){n=this.desired_size}else{this.desired_size=n}let diff=n-current_size;if(diff<=0){re_evaluate=false;this.population=this.population.slice(0,n)}else{re_evaluate=true;while(diff>0){index=parseInt(Math.random()*max_index,10);born=this.population[index].clone();this.mutator(this,born,this.mutator_args);this.population.push(born);diff--}}return re_evaluate}remove_duplicate_fitness(){this.order_population();let real_size=this.population.length;let new_fit;let new_population=[this.population[0]];let current_fit=new_population[0].get_fitness();for(let i=1;i<real_size;i++){new_fit=this.population[i].get_fitness();if(current_fit.toString()!=new_fit.toString()){new_population.push(this.population[i]);current_fit=new_fit}}this.population=new_population}get_size(){if(this.population){return this.population.length}else{return 0}}get_desired_size(){return this.desired_size}set_generation(g){this.current_gen=g}get_generation(){return this.current_gen}order_individual(a,b){let a_fit=a.get_fitness();let b_fit=b.get_fitness();for(let i=0;i<this.target_obj.length;i++){let objective=this.target_obj[i];let x,y;if(a_fit===null){x=Infinity}else{x=a_fit[objective]}if(b_fit===null){y=Infinity}else{y=b_fit[objective]}if(x>y){if(this.obj_factors[objective]>0){return-1}else{return 1}}else if(x<y){if(this.obj_factors[objective]>0){return 1}else{return-1}}}return 0}order_population(objectives=null){if(objectives===null){objectives=[];for(let i=0;i<this.obj_factors.length;i++){objectives.push(i)}}this.target_obj=objectives;this.population.sort(this.order_individual.bind(this))}get_individual(i){return this.population[i]}set_evals(evals,factors){if(evals.length==factors.length){this.objectives=evals;this.obj_factors=factors}else{throw"Both arguments must be the same size"}}get_obj_factors(i=null){if(i===null){return this.obj_factors}else{return this.obj_factors[i]}}set_constraints(constraints,max_penalties){let n_penalties=max_penalties.length;let n_constraints=constraints.length;if(n_penalties==this.objectives.length){this.constraints=constraints;this.penalties=[];for(let i=0;i<n_penalties;i++){this.penalties.push(max_penalties[i]/n_constraints)}}else{throw"max_penalities and constraints must have as many elements "+"as objectives have the task"}}set_mutator(mutator,args=[]){this.mutator=mutator;this.mutator_args=args}set_mutator_arg(key,value){this.mutator_args[key]=value}set_crossover(crossover,args=[]){this.crossover=crossover;this.crossover_args=args}set_crossover_arg(key,value){this.crossover_args[key]=value}set_selector(selector,args=[]){this.selector=selector;this.selector_args=args}set_selector_arg(key,value){this.selector_args[key]=value}set_data(data){this.data=data}get_data(){return this.data}evaluate(){let data=this.data;let n_evals=this.objectives.length;let n_constraints=this.constraints?this.constraints.length:0;for(let i=0;i<this.population.length;i++){let son=this.population[i];let fit;let son_genome;let failed;if(son.get_fitness()===null){fit=[];son_genome=son.get_genome();failed=0;for(let j=0;j<n_constraints;j++){failed+=this.constraints[j](son_genome,data)}if(failed==0){for(let k=0;k<n_evals;k++){fit.push(this.objectives[k](son_genome,data))}}else{for(let l=0;l<n_evals;l++){fit.push(this.penalties[l]*failed)}}son.set_fitness(fit)}}}mutate(){let pop_size=this.population.length;for(let i=0;i<pop_size;i++){this.mutator(this,this.population[i],this.mutator_args)}}apply_selection(){this.selector(this,this.selector_args)}apply_crossover(ind_a,ind_b){return this.crossover(this,ind_a,ind_b,this.crossover_args)}}