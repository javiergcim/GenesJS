import{Individual}from"./individual.js";import{BinaryInd}from"./binaryind.js";import{fisher_yates}from"./utils.js";export function init_permutation_pop(n,elements){if(n<2){n=2}const new_pop=[];for(let i=0;i<n;i++){const genome=[...elements];fisher_yates(genome);new_pop.push(new Individual(genome))}return new_pop}export function init_float_pop(n,numbers,min,max){if(n<2){n=2}const new_pop=[];for(let i=0;i<n;i++){const genome=[];for(let j=0;j<numbers;j++){const range=max-min;genome.push(Math.random()*range+min)}new_pop.push(new Individual(genome))}return new_pop}export function init_binary_pop(n,structure){if(n<2){n=2}let total_bits=0;let var_bits=[];let sign_bits=[];let precalc=[];const n_vars=structure.length;for(const i of structure){const current_bits=i.reduce((acc,val)=>acc+val,0);total_bits+=current_bits;var_bits.push(current_bits);sign_bits.push(i[0]);precalc.push(1/Math.pow(2,i[2]))}const vault=["0","1"];const new_pop=[];for(let i=0;i<n;i++){const genome=[];for(let j=0;j<total_bits;j++){genome.push(vault[Math.floor(Math.random()*2)])}new_pop.push(new BinaryInd(genome,var_bits,sign_bits,precalc,structure))}return new_pop}