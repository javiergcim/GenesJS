export function geometric_dist(p){if(p==1||p<=0){return p===1?1:Infinity}return Math.ceil(Math.log(1-Math.random())/Math.log(1-p))}export function gauss_dist(mean,sd,integer){const x=1-Math.random();const y=Math.random();const v=Math.sqrt(-2*Math.log(x))*Math.cos(2*Math.PI*y)*sd+mean;if(integer){return Math.round(v)}else{return v}}export function dec_to_bin(num,sign,i_dig,d_dig){let max_abs_value=Math.pow(2,i_dig)-1+(Math.pow(2,d_dig)-1)/Math.pow(2,d_dig);let binary;if(sign){if(num<0){binary=["1"]}else{binary=["0"]}}else{binary=[]}let tmp_binary;let abs_num;let numint;let numdec;let binint;let bindec;if(num<0&&!sign){tmp_binary=new Array(i_dig+d_dig).fill("0");binary.concat(tmp_binary)}else if(Math.abs(num)>=max_abs_value){tmp_binary=new Array(i_dig+d_dig).fill("1");binary.concat(tmp_binary)}else{abs_num=Math.abs(num);numint=Math.floor(abs_num);numdec=abs_num-numint;binint=new Array(i_dig).fill("0").concat(numint.toString(2).split(""));binint=binint.slice(-i_dig);numdec=Math.floor(numdec*Math.pow(2,d_dig));bindec=new Array(d_dig).fill("0").concat(numdec.toString(2).split(""));bindec=bindec.slice(-d_dig);binary=binary.concat(binint);binary=binary.concat(bindec)}return binary}export function fisher_yates(elements){for(let i=elements.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[elements[i],elements[j]]=[elements[j],elements[i]]}}export function sample_for_range(min,max,n){const elements=Array.from({length:max-min+1},(_,i)=>min+i);const max_i=max-min;let i=0;let r;let temp;while(i<=n){r=Math.floor(Math.random()*(max_i-i+1))+i;temp=elements[r];elements[r]=elements[i];elements[i]=temp;i++}return elements.slice(0,n)}export function euclidean_distance(a,b){return a.map((x,i)=>Math.abs(x-b[i])**2).reduce((sum,now)=>sum+now)**.5}export function haversine_distance(lat_from,long_from,lat_to,long_to,sphere_radius=6371e3){lat_from=lat_from*(Math.PI/180);long_from=long_from*(Math.PI/180);lat_to=lat_to*(Math.PI/180);long_to=long_to*(Math.PI/180);let lat_delta=lat_to-lat_from;let long_delta=long_to-long_from;let angle=2*Math.asin(Math.sqrt(Math.pow(Math.sin(lat_delta/2),2)+Math.cos(lat_from)*Math.cos(lat_to)*Math.pow(Math.sin(long_delta/2),2)));return angle*sphere_radius}export function create_distance_matrix(points,euclidean=false){const pointsMap=new Map;for(let i=0;i<points.length;i++){pointsMap.set(points[i].id,i)}const matrix={};for(const value of points){matrix[value.id]={}}for(const valueFrom of points){const keyFrom=valueFrom.id;for(const valueTo of points){const keyTo=valueTo.id;if(keyFrom===keyTo){matrix[keyFrom][keyTo]=0;break}if(euclidean){matrix[keyFrom][keyTo]=euclidean_distance(points[pointsMap.get(keyFrom)].coords,points[pointsMap.get(keyTo)].coords)}else{matrix[keyFrom][keyTo]=haversine_distance(points[pointsMap.get(keyFrom)].latitude,points[pointsMap.get(keyFrom)].longitude,points[pointsMap.get(keyTo)].latitude,points[pointsMap.get(keyTo)].longitude)}matrix[keyTo][keyFrom]=matrix[keyFrom][keyTo]}}return matrix}export function travel_cost(genome,data){const start=data.start;const max_i=genome.length-2;const matrix=data.cost;let cost=matrix[start][genome[0]];for(let i=0;i<=max_i;i++){cost+=matrix[genome[i]][genome[i+1]]}if(data.circuit){cost+=matrix[genome[genome.length-1]][start]}return cost}