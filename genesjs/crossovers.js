export function crossover_scx(task,ind_a,ind_b,args){const data=task.get_data();const cost=data["cost"];const start=data["start"];const circuit=data["circuit"];const obj_factors=task.get_obj_factors();const minim=obj_factors[0]>0?false:true;const gen_a=ind_a.get_raw_genome();const gen_b=ind_b.get_raw_genome();const size=gen_a.length;const size_1=size-1;const map_a=new Map;const map_b=new Map;for(let i=0;i<size;i++){map_a.set(gen_a[i],i);map_b.set(gen_b[i],i)}const legal_nodes_l=new Set(gen_a);const legal_nodes_r=new Set(legal_nodes_l);const son_l_gen=[];var cost_a=cost[start][gen_a[0]];var cost_b=cost[start][gen_b[0]];let last_added_l;if(cost_a<cost_b!==minim){last_added_l=gen_b[0]}else{last_added_l=gen_a[0]}son_l_gen.push(last_added_l);legal_nodes_l.delete(last_added_l);const son_r_gen=new Array(size).fill(null);let current_index=size_1;cost_a=cost[gen_a[size_1]][start];cost_b=cost[gen_b[size_1]][start];let last_added_r;if(circuit){if(cost_a<cost_b!==minim){last_added_r=gen_b[size_1]}else{last_added_r=gen_a[size_1]}}else{if(cost_a>cost_b!==minim){last_added_r=gen_b[size_1]}else{last_added_r=gen_a[size_1]}}son_r_gen[current_index]=last_added_r;legal_nodes_r.delete(last_added_r);current_index--;var candidate_a;var candidate_b;while(current_index>=0){let not_found=true;for(let i=map_a.get(last_added_l)+1;i<size;i++){if(legal_nodes_l.has(gen_a[i])){candidate_a=gen_a[i];not_found=false;break}}if(not_found){for(let i=0;i<size;i++){if(legal_nodes_l.has(gen_a[i])){candidate_a=gen_a[i];break}}}cost_a=cost[last_added_l][candidate_a];not_found=true;for(let i=map_b.get(last_added_l)+1;i<size;i++){if(legal_nodes_l.has(gen_b[i])){candidate_b=gen_b[i];not_found=false;break}}if(not_found){for(let i=0;i<size;i++){if(legal_nodes_l.has(gen_b[i])){candidate_b=gen_b[i];break}}}cost_b=cost[last_added_l][candidate_b];if(cost_a<cost_b!==minim){last_added_l=candidate_b}else{last_added_l=candidate_a}son_l_gen.push(last_added_l);legal_nodes_l.delete(last_added_l);not_found=true;for(let i=map_a.get(last_added_r)-1;i>=0;i--){if(legal_nodes_r.has(gen_a[i])){candidate_a=gen_a[i];not_found=false;break}}if(not_found){for(let i=size_1;i>=0;i--){if(legal_nodes_r.has(gen_a[i])){candidate_a=gen_a[i];break}}}cost_a=cost[candidate_a][last_added_r];not_found=true;for(let i=map_b.get(last_added_r)-1;i>=0;i--){if(legal_nodes_r.has(gen_b[i])){candidate_b=gen_b[i];not_found=false;break}}if(not_found){for(let i=size_1;i>=0;i--){if(legal_nodes_r.has(gen_b[i])){candidate_b=gen_b[i];break}}}cost_b=cost[candidate_b][last_added_r];if(cost_a<cost_b!==minim){last_added_r=candidate_b}else{last_added_r=candidate_a}son_r_gen[current_index]=last_added_r;legal_nodes_r.delete(last_added_r);current_index--}const a=ind_a.clone();a.set_genome_from_raw(son_l_gen);a.set_fitness(null);const b=ind_b.clone();b.set_genome_from_raw(son_r_gen);b.set_fitness(null);return[a,b]}export function crossover_pseudoscx(task,ind_a,ind_b,args){const gen_a=ind_a.get_raw_genome();const gen_b=ind_b.get_raw_genome();const size=gen_a.length;const size_1=size-1;const map_a=new Map;const map_b=new Map;for(let i=0;i<size;i++){map_a.set(gen_a[i],i);map_b.set(gen_b[i],i)}const legal_nodes_l=new Set(gen_a);const legal_nodes_r=new Set(legal_nodes_l);let last_added_l=gen_a[0];const son_l_gen=[last_added_l];legal_nodes_l.delete(last_added_l);let last_added_r=gen_a[size-1];const son_r_gen=Array(size).fill(null);son_r_gen[size-1]=last_added_r;let current_index=size_1-1;legal_nodes_r.delete(last_added_r);var next_source="a";var not_found;while(current_index>=0){if(next_source=="a"){next_source="b"}else{next_source="a"}if(next_source==="a"){not_found=true;for(let i=map_a.get(last_added_l)+1;i<size;i++){if(legal_nodes_l.has(gen_a[i])){last_added_l=gen_a[i];not_found=false;break}}if(not_found){for(let i of gen_a){if(legal_nodes_l.has(i)){last_added_l=i;break}}}}else{not_found=true;for(let i=map_b.get(last_added_l)+1;i<size;i++){if(legal_nodes_l.has(gen_b[i])){last_added_l=gen_b[i];not_found=false;break}}if(not_found){for(let i of gen_b){if(legal_nodes_l.has(i)){last_added_l=i;break}}}}son_l_gen.push(last_added_l);legal_nodes_l.delete(last_added_l);if(next_source==="a"){not_found=true;for(let i=map_a.get(last_added_r)-1;i>=0;i--){if(legal_nodes_r.has(gen_a[i])){last_added_r=gen_a[i];not_found=false;break}}if(not_found){for(let i=size_1;i>=0;i--){if(legal_nodes_r.has(gen_a[i])){last_added_r=gen_a[i];break}}}}else{not_found=true;for(let i=map_b.get(last_added_r)-1;i>=0;i--){if(legal_nodes_r.has(gen_b[i])){last_added_r=gen_b[i];not_found=false;break}}if(not_found){for(let i=size_1;i>=0;i--){if(legal_nodes_r.has(gen_b[i])){last_added_r=gen_b[i];break}}}}son_r_gen[current_index]=last_added_r;legal_nodes_r.delete(last_added_r);current_index--}const a=ind_a.clone();a.set_genome_from_raw(son_l_gen);a.set_fitness(null);const b=ind_b.clone();b.set_genome_from_raw(son_r_gen);b.set_fitness(null);return[a,b]}export function crossover_one_point(task,ind_a,ind_b,args){const gen_a=ind_a.get_raw_genome();const gen_b=ind_b.get_raw_genome();const cut_point=Math.floor(Math.random()*(gen_a.length-1))+1;const left_a=gen_a.slice(0,cut_point);const right_a=gen_a.slice(cut_point);const left_b=gen_b.slice(0,cut_point);const right_b=gen_b.slice(cut_point);const son_l_gen=left_a.concat(right_b);const son_r_gen=left_b.concat(right_a);const a=ind_a.clone();a.set_genome_from_raw(son_l_gen);a.set_fitness(null);const b=ind_b.clone();b.set_genome_from_raw(son_r_gen);b.set_fitness(null);return[a,b]}export function crossover_two_points(task,ind_a,ind_b,args){const gen_a=ind_a.get_raw_genome();const gen_b=ind_b.get_raw_genome();const cut_a=Math.floor(Math.random()*gen_a.length);const cut_b=Math.floor(Math.random()*gen_a.length);const[start,end]=[Math.min(cut_a,cut_b),Math.max(cut_a,cut_b)];const left_a=gen_a.slice(0,start);const center_a=gen_a.slice(start,end);const right_a=gen_a.slice(end);const left_b=gen_b.slice(0,start);const center_b=gen_b.slice(start,end);const right_b=gen_b.slice(end);const son_l_gen=left_a.concat(center_b,right_a);const son_r_gen=left_b.concat(center_a,right_b);const a=ind_a.clone();a.set_genome_from_raw(son_l_gen);a.set_fitness(null);const b=ind_b.clone();b.set_genome_from_raw(son_r_gen);b.set_fitness(null);return[a,b]}