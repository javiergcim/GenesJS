import{geometric_dist,gauss_dist}from"./utils.js";export function mutate_swap(task,individual,args){let changed=false;const mp=args.mp;const gen=individual.get_raw_genome();const max_i=gen.length-1;let j=geometric_dist(mp)-1;let k;let tmp;while(j<=max_i){k=Math.floor(Math.random()*(max_i+1));tmp=gen[j];gen[j]=gen[k];gen[k]=tmp;j+=geometric_dist(mp);changed=true}if(changed){individual.set_genome_from_raw(gen);individual.set_fitness(null)}}export function mutate_flip(task,individual,args){let changed=false;const mp=args.mp;const gen=individual.get_raw_genome();const max_i=gen.length-1;let j=geometric_dist(mp)-1;while(j<=max_i){if(gen[j]==="0"){gen[j]="1"}else{gen[j]="0"}j+=geometric_dist(mp);changed=true}if(changed){individual.set_genome_from_raw(gen);individual.set_fitness(null)}}export function mutate_insert(task,individual,args){let changed=true;var gen=individual.get_raw_genome();const max_i=gen.length-1;var a=Math.floor(Math.random()*(max_i+1));var b=Math.floor(Math.random()*(max_i+1));var tmp;if(b<a){tmp=a;a=b;b=tmp}else if(b===a){changed=false}const slice_a=gen.slice(0,a);const slice_b=gen.slice(a,b);const slice_c=gen.slice(b);gen=slice_a.concat(slice_c,slice_b);if(changed){individual.set_genome_from_raw(gen);individual.set_fitness(null)}}export function mutate_multiple(task,individual,args){const max_operators_index=args.operators.length-1;const operator_index=Math.floor(Math.random()*(max_operators_index+1));args.operators[operator_index](task,individual,args)}export function mutate_normal(task,individual,args){let changed=false;const mp=args.mp;const sd=args.sd;const integer=args.integer;const gen=individual.get_raw_genome();const max_i=gen.length-1;let j=geometric_dist(mp)-1;while(j<=max_i){const mean=gen[j];gen[j]=gauss_dist(mean,sd,integer);j+=geometric_dist(mp);changed=true}if(changed){individual.set_genome_from_raw(gen);individual.set_fitness(null)}}